<!DOCTYPE html>
<!-- saved from url=(0076)https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html -->
<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>第 9 章: Monad · JS函数式编程指南</title>
        
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.1.1">
        <meta name="author" content="Linghao Li">
        
        
    
    <link rel="stylesheet" href="./第 9 章_ Monad · JS函数式编程指南_files/style.css">

    
            
                
                <link rel="stylesheet" href="./第 9 章_ Monad · JS函数式编程指南_files/plugin.css">
                
            
                
                <link rel="stylesheet" href="./第 9 章_ Monad · JS函数式编程指南_files/website.css">
                
            
                
                <link rel="stylesheet" href="./第 9 章_ Monad · JS函数式编程指南_files/search.css">
                
            
                
                <link rel="stylesheet" href="./第 9 章_ Monad · JS函数式编程指南_files/website(1).css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html">
    
    
    <link rel="prev" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html">
    

    </head>
    <body>
        
<div class="book without-animation with-summary font-size-2 font-family-1">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese" target="_blank" class="custom-link">JS函数式编程指南</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch1.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html">
            
                    
                    第 1 章: 我们在做什么？
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="ch1.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html#介绍">
            
                    
                    介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="ch1.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html#一个简单例子">
            
                    
                    一个简单例子
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch2.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html">
            
                    
                    第 2 章: 一等公民的函数
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="ch2.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#快速概览">
            
                    
                    快速概览
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="ch2.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#为何钟爱一等公民">
            
                    
                    为何钟爱一等公民
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html">
            
                    
                    第 3 章: 纯函数的好处
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#再次强调“纯”">
            
                    
                    再次强调“纯”
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#副作用可能包括">
            
                    
                    副作用可能包括...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#八年级数学">
            
                    
                    八年级数学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#追求“纯”的理由">
            
                    
                    追求“纯”的理由
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="ch3.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch4.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html">
            
                    
                    第 4 章: 柯里化（curry）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="ch4.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#不可或缺的-curry">
            
                    
                    不可或缺的 curry
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="ch4.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#不仅仅是双关语咖喱">
            
                    
                    不仅仅是双关语／咖喱
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="ch4.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html">
            
                    
                    第 5 章: 代码组合（compose）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#函数饲养">
            
                    
                    函数饲养
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#pointfree">
            
                    
                    pointfree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#debug">
            
                    
                    debug
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#范畴学">
            
                    
                    范畴学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="ch5.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch6.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch6.html">
            
                    
                    第 6章: 示例应用
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="ch6.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch6.html#声明式代码">
            
                    
                    声明式代码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="ch6.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch6.html#一个函数式的-flickr">
            
                    
                    一个函数式的 flickr
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="ch6.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch6.html#有原则的重构">
            
                    
                    有原则的重构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="ch6.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch6.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html">
            
                    
                    第 7 章: Hindley-Milner 类型签名
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#初识类型">
            
                    
                    初识类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#神秘的传奇故事">
            
                    
                    神秘的传奇故事
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#缩小可能性范围">
            
                    
                    缩小可能性范围
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#自由定理">
            
                    
                    自由定理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="ch7.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html">
            
                    
                    第 8 章: 特百惠
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#强大的容器">
            
                    
                    强大的容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#第一个-functor">
            
                    
                    第一个 functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#薛定谔的-maybe">
            
                    
                    薛定谔的 Maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#“纯”错误处理">
            
                    
                    “纯”错误处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#王老先生有作用">
            
                    
                    王老先生有作用...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#异步任务">
            
                    
                    异步任务
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#一点理论">
            
                    
                    一点理论
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="ch8.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.10" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html">
            
                    
                    第 9 章: Monad
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter" data-level="1.10.1" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#pointed-functor">
            
                    
                    pointed functor
            
                </a>
            

            
        </li>
    
        <li class="chapter" data-level="1.10.2" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#混合比喻">
            
                    
                    混合比喻
            
                </a>
            

            
        </li>
    
        <li class="chapter" data-level="1.10.3" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#chain-函数">
            
                    
                    chain 函数
            
                </a>
            

            
        </li>
    
        <li class="chapter" data-level="1.10.4" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#理论">
            
                    
                    理论
            
                </a>
            

            
        </li>
    
        <li class="chapter" data-level="1.10.5" data-path="ch9.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html">
            
                    
                    第 10 章: Applicative Functor
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#应用-applicative-functor">
            
                    
                    应用 applicative functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#瓶中之船">
            
                    
                    瓶中之船
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#协调于激励">
            
                    
                    协调于激励
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift">
            
                    
                    lift
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#免费开瓶器">
            
                    
                    免费开瓶器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#定律">
            
                    
                    定律
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="ch10.html">
            
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#总结">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com/" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <a class="btn pull-left js-toolbar-action" aria-label="" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#"><i class="fa fa-align-justify"></i></a><div class="dropdown pull-right  js-toolbar-action"><a class="btn toggle-dropdown" aria-label="Share" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#"><i class="fa fa-share-alt"></i></a><div class="dropdown-menu dropdown-left"><div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div><div class="buttons"><button class="button size-5 ">Facebook</button><button class="button size-5 ">Google+</button><button class="button size-5 ">Twitter</button><button class="button size-5 ">Weibo</button><button class="button size-5 ">Instapaper</button></div></div></div><a class="btn pull-right js-toolbar-action" aria-label="" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#"><i class="fa fa-facebook"></i></a><a class="btn pull-right js-toolbar-action" aria-label="" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#"><i class="fa fa-twitter"></i></a><div class="dropdown pull-left font-settings js-toolbar-action"><a class="btn toggle-dropdown" aria-label="Font Settings" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#"><i class="fa fa-font"></i></a><div class="dropdown-menu dropdown-right"><div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div><div class="buttons"><button class="button size-2 font-reduce">A</button><button class="button size-2 font-enlarge">A</button></div><div class="buttons"><button class="button size-2 ">Serif</button><button class="button size-2 ">Sans</button></div><div class="buttons"><button class="button size-3 ">White</button><button class="button size-3 ">Sepia</button><button class="button size-3 ">Night</button></div></div></div><h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">第 9 章: Monad</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="monad">Monad</h1>
<h2 id="pointed-functor">pointed functor</h2>
<p class="comments-section">在继续后面的内容之前，我得向你坦白一件事：关于我们先前创建的容器类型上的 <code>of</code> 方法，我并没有说出它的全部实情。真实情况是，<code>of</code> 方法不是用来避免使用 <code>new</code> 关键字的，而是用来把值放到<em>默认最小化上下文</em>（default minimal context）中的。是的，<code>of</code> 没有真正地取代构造器——它是一个我们称之为 <em>pointed</em> 的重要接口的一部分。<div class="comments-icon"><div class="marker">+</div></div></p>
<blockquote>
<p class="comments-section"><em>pointed functor</em> 是实现了 <code>of</code> 方法的 functor。<div class="comments-icon"><div class="marker">+</div></div></p>
</blockquote>
<p class="comments-section">这里的关键是把任意值丢到容器里然后开始到处使用 <code>map</code> 的能力。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">IO.of(<span class="hljs-string">"tetris"</span>).map(concat(<span class="hljs-string">" master"</span>));
<span class="hljs-comment">// IO("tetris master")</span>

Maybe.of(<span class="hljs-number">1336</span>).map(add(<span class="hljs-number">1</span>));
<span class="hljs-comment">// Maybe(1337)</span>

Task.of([{id: <span class="hljs-number">2</span>}, {id: <span class="hljs-number">3</span>}]).map(_.prop(<span class="hljs-string">'id'</span>));
<span class="hljs-comment">// Task([2,3])</span>

Either.of(<span class="hljs-string">"The past, present and future walk into a bar..."</span>).map(
  concat(<span class="hljs-string">"it was tense."</span>)
);
<span class="hljs-comment">// Right("The past, present and future walk into a bar...it was tense.")</span>
</code></pre>
<p class="comments-section">如果你还记得，<code>IO</code> 和 <code>Task</code> 的构造器接受一个函数作为参数，而 <code>Maybe</code> 和 <code>Either</code> 的构造器可以接受任意值。实现这种接口的动机是，我们希望能有一种通用、一致的方式往 functor 里填值，而且中间不会涉及到复杂性，也不会涉及到对构造器的特定要求。“默认最小化上下文”这个术语可能不够精确，但是却很好地传达了这种理念：我们希望容器类型里的任意值都能发生 <code>lift</code>，然后像所有的 functor 那样再 <code>map</code> 出去。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">有件很重要的事我必须得在这里纠正，那就是，<code>Left.of</code> 没有任何道理可言，包括它的双关语也是。每个 functor 都要有一种把值放进去的方式，对 <code>Either</code> 来说，它的方式就是 <code>new Right(x)</code>。我们为 <code>Right</code> 定义 <code>of</code> 的原因是，如果一个类型容器<em>可以</em> <code>map</code>，那它就<em>应该</em> <code>map</code>。看上面的例子，你应该会对 <code>of</code> 通常的工作模式有一个直观的印象，而 <code>Left</code> 破坏了这种模式。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">你可能已经听说过 <code>pure</code>、<code>point</code>、<code>unit</code> 和 <code>return</code> 之类的函数了，它们都是 <code>of</code> 这个史上最神秘函数的不同名称（译者注：此处原文是“international function of mystery”，源自恶搞《007》的电影 <em>Austin Powers: International Man of Mystery</em>，中译名《王牌大贱谍》）。<code>of</code> 将在我们开始使用 monad 的时候显示其重要性，因为后面你会看到，手动把值放回容器是我们自己的责任。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">要避免 <code>new</code> 关键字，可以借助一些标准的 JavaScript 技巧或者类库达到目的。所以从这里开始，我们就利用这些技巧或类库，像一个负责任的成年人那样使用 <code>of</code>。我推荐使用 <code>folktale</code>、<code>ramda</code> 或 <code>fantasy-land</code> 里的 functor 实例，因为它们同时提供了正确的 <code>of</code> 方法和不依赖 <code>new</code> 的构造器。<div class="comments-icon"><div class="marker">+</div></div></p>
<h2 id="混合比喻">混合比喻</h2>
<p><img src="./第 9 章_ Monad · JS函数式编程指南_files/onion.png" alt="http://www.organicchemistry.com/wp-content/uploads/BPOCchapter6-6htm-41.png"></p>
<p class="comments-section">你看，除了太空墨西哥卷（如果你听说过这个传言的话）（译者注：此处的传言似乎是说一个叫 Chris Hadfield 的宇航员在国际空间站做墨西哥卷的事，<a href="https://www.youtube.com/watch?v=f8-UKqGZ_hs" target="_blank">视频链接</a>），monad 还被喻为洋葱。让我以一个常见的场景来说明这点：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">// Support</span>
<span class="hljs-comment">// ===========================</span>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">//  readFile :: String -&gt; IO String</span>
<span class="hljs-keyword">var</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> fs.readFileSync(filename, <span class="hljs-string">'utf-8'</span>);
  });
};

<span class="hljs-comment">//  print :: String -&gt; IO String</span>
<span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(x);
    <span class="hljs-keyword">return</span> x;
  });
}

<span class="hljs-comment">// Example</span>
<span class="hljs-comment">// ===========================</span>
<span class="hljs-comment">//  cat :: IO (IO String)</span>
<span class="hljs-keyword">var</span> cat = compose(map(print), readFile);

cat(<span class="hljs-string">".git/config"</span>)
<span class="hljs-comment">// IO(IO("[core]\nrepositoryformatversion = 0\n"))</span>
</code></pre>
<p class="comments-section">这里我们得到的是一个 <code>IO</code>，只不过它陷进了另一个 <code>IO</code>。要想使用它，我们必须这样调用： <code>map(map(f))</code>；要想观察它的作用，必须这样： <code>unsafePerformIO().unsafePerformIO()</code>。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  cat :: String -&gt; IO (IO String)</span>
<span class="hljs-keyword">var</span> cat = compose(map(print), readFile);

<span class="hljs-comment">//  catFirstChar :: String -&gt; IO (IO String)</span>
<span class="hljs-keyword">var</span> catFirstChar = compose(map(map(head)), cat);

catFirstChar(<span class="hljs-string">".git/config"</span>)
<span class="hljs-comment">// IO(IO("["))</span>
</code></pre>
<p class="comments-section">尽管在应用中把这两个作用打包在一起没什么不好的，但总感觉像是在穿着两套防护服工作，结果就形成一个稀奇古怪的 API。再来看另一种情况：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  safeProp :: Key -&gt; {Key: a} -&gt; Maybe a</span>
<span class="hljs-keyword">var</span> safeProp = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, obj</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Maybe(obj[x]);
});

<span class="hljs-comment">//  safeHead :: [a] -&gt; Maybe a</span>
<span class="hljs-keyword">var</span> safeHead = safeProp(<span class="hljs-number">0</span>);

<span class="hljs-comment">//  firstAddressStreet :: User -&gt; Maybe (Maybe (Maybe Street) )</span>
<span class="hljs-keyword">var</span> firstAddressStreet = compose(
  map(map(safeProp(<span class="hljs-string">'street'</span>))), map(safeHead), safeProp(<span class="hljs-string">'addresses'</span>)
);

firstAddressStreet(
  {addresses: [{street: {name: <span class="hljs-string">'Mulburry'</span>, number: <span class="hljs-number">8402</span>}, postcode: <span class="hljs-string">"WC2N"</span> }]}
);
<span class="hljs-comment">// Maybe(Maybe(Maybe({name: 'Mulburry', number: 8402})))</span>
</code></pre>
<p class="comments-section">这里的 functor 同样是嵌套的，函数中三个可能的失败都用了 <code>Maybe</code> 做预防也很干净整洁，但是要让最后的调用者调用三次 <code>map</code> 才能取到值未免也太无礼了点——我们和它才刚刚见面而已。这种嵌套 functor 的模式会时不时地出现，而且是 monad 的主要使用场景。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">我说过 monad 像洋葱，那是因为当我们用 <code>map</code> 剥开嵌套的 functor 以获取它里面的值的时候，就像剥洋葱一样让人忍不住想哭。不过，我们可以擦干眼泪，做个深呼吸，然后使用一个叫作 <code>join</code> 的方法。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> mmo = Maybe.of(Maybe.of(<span class="hljs-string">"nunchucks"</span>));
<span class="hljs-comment">// Maybe(Maybe("nunchucks"))</span>

mmo.join();
<span class="hljs-comment">// Maybe("nunchucks")</span>

<span class="hljs-keyword">var</span> ioio = IO.of(IO.of(<span class="hljs-string">"pizza"</span>));
<span class="hljs-comment">// IO(IO("pizza"))</span>

ioio.join()
<span class="hljs-comment">// IO("pizza")</span>

<span class="hljs-keyword">var</span> ttt = Task.of(Task.of(Task.of(<span class="hljs-string">"sewers"</span>)));
<span class="hljs-comment">// Task(Task(Task("sewers")));</span>

ttt.join()
<span class="hljs-comment">// Task(Task("sewers"))</span>
</code></pre>
<p class="comments-section">如果有两层相同类型的嵌套，那么就可以用 <code>join</code> 把它们压扁到一块去。这种结合的能力，functor 之间的联姻，就是 monad 之所以成为 monad 的原因。来看看它更精确的完整定义：<div class="comments-icon"><div class="marker">+</div></div></p>
<blockquote>
<p class="comments-section">monad 是可以变扁（flatten）的 pointed functor。<div class="comments-icon"><div class="marker">+</div></div></p>
</blockquote>
<p class="comments-section">一个 functor，只要它定义个了一个 <code>join</code> 方法和一个 <code>of</code> 方法，并遵守一些定律，那么它就是一个 monad。<code>join</code> 的实现并不太复杂，我们来为 <code>Maybe</code> 定义一个：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">Maybe.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing() ? Maybe.of(<span class="hljs-literal">null</span>) : <span class="hljs-keyword">this</span>.__value;
}
</code></pre>
<p class="comments-section">看，就像子宫里双胞胎中的一个吃掉另一个那么简单。如果有一个 <code>Maybe(Maybe(x))</code>，那么 <code>.__value</code> 将会移除多余的一层，然后我们就能安心地从那开始进行 <code>map</code>。要不然，我们就将会只有一个 <code>Maybe</code>，因为从一开始就没有任何东西被 <code>map</code> 调用。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">既然已经有了 <code>join</code> 方法，我们把 monad 魔法作用到 <code>firstAddressStreet</code> 例子上，看看它的实际作用：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  join :: Monad m =&gt; m (m a) -&gt; m a</span>
<span class="hljs-keyword">var</span> join = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mma</span>)</span>{ <span class="hljs-keyword">return</span> mma.join(); }

<span class="hljs-comment">//  firstAddressStreet :: User -&gt; Maybe Street</span>
<span class="hljs-keyword">var</span> firstAddressStreet = compose(
  join, map(safeProp(<span class="hljs-string">'street'</span>)), join, map(safeHead), safeProp(<span class="hljs-string">'addresses'</span>)
);

firstAddressStreet(
  {addresses: [{street: {name: <span class="hljs-string">'Mulburry'</span>, number: <span class="hljs-number">8402</span>}, postcode: <span class="hljs-string">"WC2N"</span> }]}
);
<span class="hljs-comment">// Maybe({name: 'Mulburry', number: 8402})</span>
</code></pre>
<p class="comments-section">只要遇到嵌套的 <code>Maybe</code>，就加一个 <code>join</code>，防止它们从手中溜走。我们对 <code>IO</code> 也这么做试试看，感受下这种感觉。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">IO.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.unsafePerformIO();
}
</code></pre>
<p class="comments-section">同样是简单地移除了一层容器。注意，我们还没有提及纯粹性的问题，仅仅是移除过度紧缩的包裹中的一层而已。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  log :: a -&gt; IO a</span>
<span class="hljs-keyword">var</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(x); <span class="hljs-keyword">return</span> x; });
}

<span class="hljs-comment">//  setStyle :: Selector -&gt; CSSProps -&gt; IO DOM</span>
<span class="hljs-keyword">var</span> setStyle = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sel, props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> jQuery(sel).css(props); });
});

<span class="hljs-comment">//  getItem :: String -&gt; IO String</span>
<span class="hljs-keyword">var</span> getItem = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> localStorage.getItem(key); });
};

<span class="hljs-comment">//  applyPreferences :: String -&gt; IO DOM</span>
<span class="hljs-keyword">var</span> applyPreferences = compose(
  join, map(setStyle(<span class="hljs-string">'#main'</span>)), join, map(log), map(<span class="hljs-built_in">JSON</span>.parse), getItem
);


applyPreferences(<span class="hljs-string">'preferences'</span>).unsafePerformIO();
<span class="hljs-comment">// Object {backgroundColor: "green"}</span>
<span class="hljs-comment">// &lt;div style="background-color: 'green'"/&gt;</span>
</code></pre>
<p class="comments-section"><code>getItem</code> 返回了一个 <code>IO String</code>，所以可以直接用 <code>map</code> 来解析它。<code>log</code> 和 <code>setStyle</code> 返回的都是 <code>IO</code>，所以必须要使用 <code>join</code> 来保证这里边的嵌套处于控制之中。<div class="comments-icon"><div class="marker">+</div></div></p>
<h2 id="chain-函数">chain 函数</h2>
<p class="comments-section">（译者注：此处标题原文是“My chain hits my chest”，是英国歌手 M.I.A 单曲 <em>Bad Girls</em> 的一句歌词。据说这首歌有体现女权主义。）<div class="comments-icon"><div class="marker">+</div></div></p>
<p><img src="./第 9 章_ Monad · JS函数式编程指南_files/chain.jpg" alt="chain"></p>
<p class="comments-section">你可能已经从上面的例子中注意到这种模式了：我们总是在紧跟着 <code>map</code> 的后面调用 <code>join</code>。让我们把这个行为抽象到一个叫做 <code>chain</code> 的函数里。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span>
<span class="hljs-keyword">var</span> chain = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, m</span>)</span>{
  <span class="hljs-keyword">return</span> m.map(f).join(); <span class="hljs-comment">// 或者 compose(join, map(f))(m)</span>
});
</code></pre>
<p class="comments-section">这里仅仅是把 map/join 套餐打包到一个单独的函数中。如果你之前了解过 monad，那你可能已经看出来 <code>chain</code> 叫做 <code>&gt;&gt;=</code>（读作 bind）或者 <code>flatMap</code>；都是同一个概念的不同名称罢了。我个人认为 <code>flatMap</code> 是最准确的名称，但本书还是坚持使用 <code>chain</code>，因为它是 JS 里接受程度最高的一个。我们用 <code>chain</code> 重构下上面两个例子：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">// map/join</span>
<span class="hljs-keyword">var</span> firstAddressStreet = compose(
  join, map(safeProp(<span class="hljs-string">'street'</span>)), join, map(safeHead), safeProp(<span class="hljs-string">'addresses'</span>)
);

<span class="hljs-comment">// chain</span>
<span class="hljs-keyword">var</span> firstAddressStreet = compose(
  chain(safeProp(<span class="hljs-string">'street'</span>)), chain(safeHead), safeProp(<span class="hljs-string">'addresses'</span>)
);



<span class="hljs-comment">// map/join</span>
<span class="hljs-keyword">var</span> applyPreferences = compose(
  join, map(setStyle(<span class="hljs-string">'#main'</span>)), join, map(log), map(<span class="hljs-built_in">JSON</span>.parse), getItem
);

<span class="hljs-comment">// chain</span>
<span class="hljs-keyword">var</span> applyPreferences = compose(
  chain(setStyle), chain(log), map(<span class="hljs-built_in">JSON</span>.parse), getItem
);
</code></pre>
<p class="comments-section">我把所有的 <code>map/join</code> 都替换为了 <code>chain</code>，这样代码就显得整洁了些。整洁固然是好事，但 <code>chain</code> 的能力却不止于此——它更多的是龙卷风而不是吸尘器。因为 <code>chain</code> 可以轻松地嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 <em>序列</em>（sequence） 和 <em>变量赋值</em>（variable assignment）。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">// getJSON :: Url -&gt; Params -&gt; Task JSON</span>
<span class="hljs-comment">// querySelector :: Selector -&gt; IO DOM</span>


getJSON(<span class="hljs-string">'/authenticate'</span>, {username: <span class="hljs-string">'stale'</span>, password: <span class="hljs-string">'crackers'</span>})
  .chain(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>{
    <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">'/friends'</span>, {user_id: user.id});
});
<span class="hljs-comment">// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);</span>


querySelector(<span class="hljs-string">"input.username"</span>).chain(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">uname</span>) </span>{
  <span class="hljs-keyword">return</span> querySelector(<span class="hljs-string">"input.email"</span>).chain(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">email</span>) </span>{
    <span class="hljs-keyword">return</span> IO.of(
      <span class="hljs-string">"Welcome "</span> + uname.value + <span class="hljs-string">" "</span> + <span class="hljs-string">"prepare for spam at "</span> + email.value
    );
  });
});
<span class="hljs-comment">// IO("Welcome Olivia prepare for spam at olivia@tremorcontrol.net");</span>


Maybe.of(<span class="hljs-number">3</span>).chain(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">three</span>) </span>{
  <span class="hljs-keyword">return</span> Maybe.of(<span class="hljs-number">2</span>).map(add(three));
});
<span class="hljs-comment">// Maybe(5);</span>


Maybe.of(<span class="hljs-literal">null</span>).chain(safeProp(<span class="hljs-string">'address'</span>)).chain(safeProp(<span class="hljs-string">'street'</span>));
<span class="hljs-comment">// Maybe(null);</span>
</code></pre>
<p class="comments-section">本来我们可以用 <code>compose</code> 写上面的例子，但这将需要几个帮助函数，而且这种风格怎么说都要通过闭包进行明确的变量赋值。相反，我们使用了插入式的 <code>chain</code>。顺便说一下，<code>chain</code> 可以自动从任意类型的 <code>map</code> 和 <code>join</code> 衍生出来，就像这样：<code>t.prototype.chain = function(f) { return this.map(f).join(); }</code>。如果手动定义 <code>chain</code> 能让你觉得性能会好点的话（实际上并不会），我们也可以手动定义它，尽管还必须要费力保证函数功能的正确性——也就是说，它必须与紧接着后面有 <code>join</code> 的 <code>map</code> 相等。如果 <code>chain</code> 是简单地通过结束调用 <code>of</code> 后把值放回容器这种方式定义的，那么就会造成一个有趣的后果，即可以从 <code>chain</code> 那里衍生出一个 <code>map</code>。同样地，我们还可以用 <code>chain(id)</code> 定义 <code>join</code>。听起来好像是在跟魔术师玩德州扑克，魔术师想要什么牌就有什么牌；但是就像大部分的数学理论一样，所有这些原则性的结构都是相互关联的。<a href="https://github.com/fantasyland/fantasy-land" target="_blank">fantasyland</a> 仓库中提到了许多上述衍生概念，这个仓库也是 JavaScript 官方的代数数据结构（algebraic data types）标准。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">好了，我们来看上面的例子。第一个例子中，可以看到两个 <code>Task</code> 通过 <code>chain</code> 连接形成了一个异步操作的序列——它先获取 <code>user</code>，然后用 <code>user.id</code> 查找 <code>user</code> 的 <code>friends</code>。<code>chain</code> 避免了 <code>Task(Task([Friend]))</code> 这种情况。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">第二个例子是用 <code>querySelector</code> 查找几个 input 然后创建一条欢迎信息。注意看我们是如何在最内层的函数里访问 <code>uname</code> 和 <code>email</code> 的——这是函数式变量赋值的绝佳表现。因为 <code>IO</code> 大方地把它的值借给了我们，我们也要负起以同样方式把值放回去的责任——不能辜负它的信任（还有整个程序的信任）。<code>IO.of</code> 非常适合做这件事，同时它也解释了为何 pointed 这一特性是 monad 接口得以存在的重要前提。不过，<code>map</code> 也能返回正确的类型：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">querySelector(<span class="hljs-string">"input.username"</span>).chain(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">uname</span>) </span>{
  <span class="hljs-keyword">return</span> querySelector(<span class="hljs-string">"input.email"</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">email</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Welcome "</span> + uname.value + <span class="hljs-string">" prepare for spam at "</span> + email.value;
  });
});
<span class="hljs-comment">// IO("Welcome Olivia prepare for spam at olivia@tremorcontrol.net");</span>
</code></pre>
<p class="comments-section">最后两个例子用了 <code>Maybe</code>。因为 <code>chain</code> 其实是在底层调用了 <code>map</code>，所以如果遇到 <code>null</code>，代码就会立刻停止运行。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">如果觉得这些例子不太容易理解，你也不必担心。多跑跑代码，多琢磨琢磨，把代码拆开来研究研究，再把它们拼起来看看。总之记住，返回的如果是“普通”值就用 <code>map</code>，如果是 <code>functor</code> 就用 <code>chain</code>。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">这里我得提醒一下，上述方式对两个不同类型的嵌套容器是不适用的。functor 组合，以及后面会讲到的 monad transformer 可以帮助我们应对这种情况。<div class="comments-icon"><div class="marker">+</div></div></p>
<h2 id="炫耀">炫耀</h2>
<p class="comments-section">这种容器编程风格有时也能造成困惑，我们不得不努力理解一个值到底嵌套了几层容器，或者需要用 <code>map</code> 还是 <code>chain</code>（很快我们就会认识更多的容器类型）。使用一些技巧，比如重写 <code>inspect</code> 方法之类，能够大幅提高 debug 的效率。后面我们也会学习如何创建一个“栈”，使之能够处理任何丢给它的作用（effects）。不过，有时候也需要权衡一下是否值得这样做。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">我很乐意挥起 monad 之剑，向你展示这种编程风格的力量。就以读一个文件，然后就把它直接上传为例吧：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">// readFile :: Filename -&gt; Either String (Future Error String)</span>
<span class="hljs-comment">// httpPost :: String -&gt; Future Error JSON</span>

<span class="hljs-comment">//  upload :: String -&gt; Either String (Future Error JSON)</span>
<span class="hljs-keyword">var</span> upload = compose(map(chain(httpPost(<span class="hljs-string">'/uploads'</span>))), readFile);
</code></pre>
<p class="comments-section">这里，代码不止一次在不同的分支执行。从类型签名可以看出，我们预防了三个错误——<code>readFile</code> 使用 <code>Either</code> 来验证输入（或许还有确保文件名存在）；<code>readFile</code> 在读取文件的时候可能会出错，错误通过 <code>readFile</code> 的 <code>Future</code> 表示；文件上传可能会因为各种各样的原因出错，错误通过 <code>httpPost</code> 的 <code>Future</code> 表示。我们就这么随意地使用 <code>chain</code> 实现了两个嵌套的、有序的异步执行动作。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">所有这些操作都是在一个从左到右的线性流中完成的，是完完全全纯的、声明式的代码，是可以等式推导（equational reasoning）并拥有可靠特性（reliable properties）的代码。我们没有被迫使用不必要甚至令人困惑的变量名，我们的 <code>upload</code> 函数符合通用接口而不是特定的一次性接口。这些都是在一行代码中完成的啊！<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">让我们来跟标准的命令式的实现对比一下：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js"><span class="hljs-comment">//  upload :: String -&gt; (String -&gt; a) -&gt; Void</span>
<span class="hljs-keyword">var</span> upload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filename, callback</span>) </span>{
  <span class="hljs-keyword">if</span>(!filename) {
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"You need a filename!"</span>;
  } <span class="hljs-keyword">else</span> {
    readFile(filename, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, contents</span>) </span>{
      <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;
      httpPost(contents, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, json</span>) </span>{
        <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;
        callback(json);
      });
    });
  }
}
</code></pre>
<p class="comments-section">看看，这简直就是魔鬼的算术（译者注：此处原文是“the devil's arithmetic”，为美国 1988 年出版的历史小说，讲述一个犹太小女孩穿越到 1942 年的集中营的故事。此书亦有同名改编电影，中译名《穿梭集中营》），我们就像一颗弹珠一样在变幻莫测的迷宫中穿梭。无法想象如果这是一个典型的应用，而且一直在改变变量会怎样——我们肯定会像陷入沥青坑那样无所适从。<div class="comments-icon"><div class="marker">+</div></div></p>
<h1 id="理论">理论</h1>
<p class="comments-section">我们要看的第一条定律是结合律，但可能不是你熟悉的那个结合律。<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">  <span class="hljs-comment">// 结合律</span>
  compose(join, map(join)) == compose(join, join)
</code></pre>
<p class="comments-section">这些定律表明了 monad 的嵌套本质，所以结合律关心的是如何让内层或外层的容器类型 <code>join</code>，然后取得同样的结果。用一张图来表示可能效果会更好：<div class="comments-icon"><div class="marker">+</div></div></p>
<p><img src="./第 9 章_ Monad · JS函数式编程指南_files/monad_associativity.png" alt="monad associativity law"></p>
<p class="comments-section">从左上角往下，先用 <code>join</code> 合并 <code>M(M(M a))</code> 最外层的两个 <code>M</code>，然后往左，再调用一次 <code>join</code>，就得到了我们想要的 <code>M a</code>。或者，从左上角往右，先打开最外层的 <code>M</code>，用 <code>map(join)</code> 合并内层的两个 <code>M</code>，然后再向下调用一次 <code>join</code>，也能得到 <code>M a</code>。不管是先合并内层还是先合并外层的 <code>M</code>，最后都会得到相同的 <code>M a</code>，所以这就是结合律。值得注意的一点是 <code>map(join) != join</code>。两种方式的中间步骤可能会有不同的值，但最后一个 <code>join</code> 调用后最终结果是一样的。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">第二个定律与结合律类似：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">  <span class="hljs-comment">// 同一律 (M a)</span>
  compose(join, <span class="hljs-keyword">of</span>) == compose(join, map(<span class="hljs-keyword">of</span>)) == id
</code></pre>
<p class="comments-section">这表明，对任意的 monad <code>M</code>，<code>of</code> 和 <code>join</code> 相当于 <code>id</code>。也可以使用 <code>map(of)</code> 由内而外实现相同效果。我们把这个定律叫做“三角同一律”（triangle identity），因为把它图形化之后就像一个三角形：<div class="comments-icon"><div class="marker">+</div></div></p>
<p><img src="./第 9 章_ Monad · JS函数式编程指南_files/triangle_identity.png" alt="monad identity law"></p>
<p class="comments-section">如果从左上角开始往右，可以看到 <code>of</code> 的确把 <code>M a</code> 丢到另一个 <code>M</code> 容器里去了。然后再往下 <code>join</code>，就得到了 <code>M a</code>，跟一开始就调用 <code>id</code> 的结果一样。从右上角往左，可以看到如果我们通过 <code>map</code> 进到了 <code>M</code> 里面，然后对普通值 <code>a</code> 调用 <code>of</code>，最后得到的还是 <code>M (M a)</code>；再调用一次 <code>join</code> 将会把我们带回原点，即 <code>M a</code>。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">我要说明一点，尽管这里我写的是 <code>of</code>，实际上对任意的 monad 而言，都必须要使用明确的 <code>M.of</code>。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">我已经见过这些定律了，同一律和结合律，以前就在哪儿见过...等一下，让我想想...是的！它们是范畴遵循的定律！不过这意味着我们需要一个组合函数来给出一个完整定义。见证吧：<div class="comments-icon"><div class="marker">+</div></div></p>
<pre><code class="lang-js">  <span class="hljs-keyword">var</span> mcompose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, g</span>) </span>{
    <span class="hljs-keyword">return</span> compose(chain(f), chain(g));
  }

  <span class="hljs-comment">// 左同一律</span>
  mcompose(M, f) == f

  <span class="hljs-comment">// 右同一律</span>
  mcompose(f, M) == f

  <span class="hljs-comment">// 结合律</span>
  mcompose(mcompose(f, g), h) == mcompose(f, mcompose(g, h))
</code></pre>
<p class="comments-section">毕竟它们是范畴学里的定律。monad 来自于一个叫 “Kleisli 范畴”的范畴，这个范畴里边所有的对象都是 monad，所有的态射都是联结函数（chained funtions）。我不是要在没有提供太多解释的情况下，拿范畴学里各式各样的概念来取笑你。我的目的是涉及足够多的表面知识，向你说明这中间的相关性，让你在关注日常实用特性之余，激发起对这些定律的兴趣。<div class="comments-icon"><div class="marker">+</div></div></p>
<h2 id="总结">总结</h2>
<p class="comments-section">monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。当一个值被困在几层相同类型的容器中时，monad 能够拯救它。借助 “pointed” 这个可靠的帮手，monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">是的，monad 非常强大，但我们还需要一些额外的容器函数。比如，假设我们想同时运行一个列表里的 api 调用，然后再搜集返回的结果，怎么办？是可以使用 monad 实现这个任务，但必须要等每一个 api 完成后才能调用下一个。合并多个合法性验证呢？我们想要的肯定是持续验证以搜集错误列表，但是 monad 会在第一个 <code>Left</code> 登场的时候停掉整个演出。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section">下一章，我们将看到 applicative functor 如何融入这个容器世界，以及为何在很多情况下它比 monad 更好用。<div class="comments-icon"><div class="marker">+</div></div></p>
<p class="comments-section"><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html">第 10 章: Applicative Functor</a><div class="comments-icon"><div class="marker">+</div></div></p>
<h2 id="练习">练习</h2>
<pre><code class="lang-js"><span class="hljs-comment">// 练习 1</span>
<span class="hljs-comment">// ==========</span>
<span class="hljs-comment">// 给定一个 user，使用 safeProp 和 map/join 或 chain 安全地获取 sreet 的 name</span>

<span class="hljs-keyword">var</span> safeProp = _.curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, o</span>) </span>{ <span class="hljs-keyword">return</span> Maybe.of(o[x]); });
<span class="hljs-keyword">var</span> user = {
  id: <span class="hljs-number">2</span>,
  name: <span class="hljs-string">"albert"</span>,
  address: {
    street: {
      number: <span class="hljs-number">22</span>,
      name: <span class="hljs-string">'Walnut St'</span>
    }
  }
};

<span class="hljs-keyword">var</span> ex1 = <span class="hljs-literal">undefined</span>;


<span class="hljs-comment">// 练习 2</span>
<span class="hljs-comment">// ==========</span>
<span class="hljs-comment">// 使用 getFile 获取文件名并删除目录，所以返回值仅仅是文件，然后以纯的方式打印文件</span>

<span class="hljs-keyword">var</span> getFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> __filename; });
}

<span class="hljs-keyword">var</span> pureLog = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(x);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'logged '</span> + x;
  });
}

<span class="hljs-keyword">var</span> ex2 = <span class="hljs-literal">undefined</span>;



<span class="hljs-comment">// 练习 3</span>
<span class="hljs-comment">// ==========</span>
<span class="hljs-comment">// 使用 getPost() 然后以 post 的 id 调用 getComments()</span>
<span class="hljs-keyword">var</span> getPost = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Task(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rej, res</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      res({ id: i, title: <span class="hljs-string">'Love them tasks'</span> });
    }, <span class="hljs-number">300</span>);
  });
}

<span class="hljs-keyword">var</span> getComments = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Task(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rej, res</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      res([
        {post_id: i, body: <span class="hljs-string">"This book should be illegal"</span>},
        {post_id: i, body: <span class="hljs-string">"Monads are like smelly shallots"</span>}
      ]);
    }, <span class="hljs-number">300</span>);
  });
}


<span class="hljs-keyword">var</span> ex3 = <span class="hljs-literal">undefined</span>;


<span class="hljs-comment">// 练习 4</span>
<span class="hljs-comment">// ==========</span>
<span class="hljs-comment">// 用 validateEmail、addToMailingList 和 emailBlast 实现 ex4 的类型签名</span>

<span class="hljs-comment">//  addToMailingList :: Email -&gt; IO([Email])</span>
<span class="hljs-keyword">var</span> addToMailingList = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">email</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      list.push(email);
      <span class="hljs-keyword">return</span> list;
    });
  }
})([]);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emailBlast</span>(<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'emailed: '</span> + list.join(<span class="hljs-string">','</span>);
  });
}

<span class="hljs-keyword">var</span> validateEmail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>{
  <span class="hljs-keyword">return</span> x.match(<span class="hljs-regexp">/\S+@\S+\.\S+/</span>) ? (<span class="hljs-keyword">new</span> Right(x)) : (<span class="hljs-keyword">new</span> Left(<span class="hljs-string">'invalid email'</span>));
}

<span class="hljs-comment">//  ex4 :: Email -&gt; Either String (IO String)</span>
<span class="hljs-keyword">var</span> ex4 = <span class="hljs-literal">undefined</span>;
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#总结" class="navigation navigation-prev " aria-label="Previous page: 总结">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#pointed-functor" class="navigation navigation-next " aria-label="Next page: pointed functor" style="margin-right: 15px;">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第 9 章: Monad","level":"1.10","depth":1,"next":{"title":"pointed functor","level":"1.10.1","depth":2,"anchor":"#pointed-functor","path":"ch9.md","ref":"ch9.md#pointed-functor","articles":[]},"previous":{"title":"总结","level":"1.9.8","depth":2,"anchor":"#总结","path":"ch8.md","ref":"ch8.md#总结","articles":[]},"dir":"ltr"},"config":{"plugins":["comment"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"comment":{"highlightCommented":true},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"github":"llh911001/mostly-adequate-guide-chinese","theme":"default","author":"Linghao Li","pdf":{"pageNumbers":true,"fontSize":16,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"JS函数式编程指南","language":"zh","links":{"sidebar":{"JS函数式编程指南":"https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese"},"gitbook":true},"gitbook":"*","description":"Mostly Adequate Guide 中文版"},"file":{"path":"ch9.md","mtime":"2016-09-19T03:35:00.000Z","type":"markdown"},"gitbook":{"version":"3.1.1","time":"2016-09-19T03:34:10.921Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="./第 9 章_ Monad · JS函数式编程指南_files/gitbook.js"></script>
    <script src="./第 9 章_ Monad · JS函数式编程指南_files/theme.js"></script>
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/plugin.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/search-engine.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/search.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/lunr.min.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/search-lunr.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/buttons.js"></script>
        
    
        
        <script src="./第 9 章_ Monad · JS函数式编程指南_files/fontsettings.js"></script>
        
    

    


</body></html>