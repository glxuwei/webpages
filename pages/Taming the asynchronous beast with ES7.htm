<!DOCTYPE html>
<!-- saved from url=(0067)https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html -->
<html lang="en" manifest="/manifest.appcache"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Taming the asynchronous beast with ES7</title>
    <link rel="alternate" title="PouchDB, the JavaScript Database that Syncs!" type="application/rss+xml" href="https://pouchdb.com/feed.xml">
    <link rel="stylesheet" href="./Taming the asynchronous beast with ES7_files/pouchdb.css">
    <meta name="theme-color" content="#6ccb99">
    <meta name="msapplication-TileColor" content="#6ccb99">
    <script type="text/javascript" async="" src="./Taming the asynchronous beast with ES7_files/ga.js"></script><script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-42479701-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <link href="./Taming the asynchronous beast with ES7_files/css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://pouchdb.com/static/favicon.ico" type="image/x-icon">
  </head>

  <body data-spy="scroll" data-target="#sidebar">

    <header role="banner">

      <a href="https://github.com/pouchdb/pouchdb" target="_blank">
         <div class="ribbon">GitHub</div>
      </a>

      <div class="container">

        <a class="logo" href="https://pouchdb.com/">
          <div class="logo-img"></div>
          <span class="sr-only">PouchDB</span>
        </a>

        <ul class="nav nav-header nav-pills" role="navigation">
          <li>
            <a class="btn btn-link btn-lg" href="https://pouchdb.com/blog/">Blog</a>
          </li>
          <li>
            <a class="btn btn-link btn-lg" href="https://pouchdb.com/guides/">Guides</a>
          </li>
          <li>
            <a class="btn btn-link btn-lg" href="https://pouchdb.com/api.html">API</a>
          </li>
          <li>
            <a class="btn btn-link btn-lg" href="https://pouchdb.com/learn.html">Learn</a>
          </li>
          <li>
            <a class="btn btn-primary btn-lg" href="https://pouchdb.com/download.html">Download <strong>v5.4.5</strong></a>
          </li>
        </ul>

      </div>

    </header>
    
      <div class="band band-inverse">

        <div class="container">

          <h1 class="margin-bottom-none">Taming the asynchronous beast with ES7</h1>
          
            <span class="h1 margin-bottom-none">
              
<a data-toggle="tooltip" data-placement="top" title="" class="icon-edit" href="https://github.com/pouchdb/pouchdb/edit/master/docs/_posts/2015-03-05-taming-the-async-beast-with-es7.md" target="_blank" data-original-title="Edit this on Github"></a>

            </span>
          
          

        </div>

      </div>
    

    <div role="main">
      <div class="band">
  <div class="container">
    <article role="article">
      









<div class="post">
  <div class="media">
    <a class="pull-left" href="https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html#">
    <img class="media-object img-circle img-responsive" src="./Taming the asynchronous beast with ES7_files/c436dec61b906e27c963518d0ef1d972" alt="Nolan Lawson">
    </a>
    <div class="media-body">
    <p>
      <strong>By:</strong> <a href="https://twitter.com/nolanlawson">Nolan Lawson</a><br>
      <strong>Published:</strong> 05 March 2015<br>
      
    </p>
    </div>
  </div>
</div>


      <p>One of the trickiest aspects of PouchDB is that its API is asynchronous. I see no shortage of confused questions on Stack Overflow, Github, and IRC, and most often they stem from a misunderstanding of callbacks and promises.</p>

<p>We can't really help it. PouchDB is an abstraction over IndexedDB, WebSQL, LevelDB (in Node), and CouchDB (via Ajax). All of those APIs are asynchronous; hence PouchDB must be asynchronous.</p>

<p>When I think of elegant database APIs, however, I'm still struck by the simplicity of LocalStorage:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">localStorage</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span></code></pre></figure>

<p>To work with LocalStorage, you simply treat it like a magical JavaScript object that happens to persist your data. It uses the same synchronous toolset that you're already used to from working with JavaScript itself.</p>

<p>For all of <a href="http://www.html5rocks.com/en/tutorials/offline/quota-research/">LocalStorage's</a> <a href="https://blog.mozilla.org/tglek/2012/02/22/psa-dom-local-storage-considered-harmful/">faults</a>, the ergonomics of this API go a long way to explain its continuing popularity. People keep using LocalStorage, because it's simple and works exactly as expected.</p>

<h3>Promises aren't a panacea</h3>

<p>For PouchDB, we can try to mitigate the complexity of asynchronous APIs with promises, and that certainly helps us escape the <a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf">pyramid of doom</a>.</p>

<p>However, promisey code is still hard to read, because promises are basically a bolt-on replacement for language primitives like <code>try</code>, <code>catch</code>, and <code>return</code>:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">db</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PouchDB</span><span class="p">(</span><span class="s1">'mydb'</span><span class="p">);</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">({}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// post a new doc</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>          <span class="c1">// fetch the doc</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>                  <span class="c1">// log the doc</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>                  <span class="c1">// log any errors</span>
<span class="p">});</span></code></pre></figure>

<p>As JavaScript developers, we now have two parallel systems – sync and async – that we have to keep straight in our heads. And this gets even worse as our control flow becomes more complex, and we need to reach for APIs like <code>Promise.all()</code> and <code>Promise.resolve()</code>. Or maybe we just opt for <a href="https://github.com/petkaantonov/bluebird">one</a> <a href="https://github.com/tildeio/rsvp.js">of</a> <a href="https://github.com/caolan/async">the</a> <a href="https://github.com/kriskowal/q">many</a> <a href="https://github.com/cujojs/when">helper</a> <a href="https://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">libraries</a> and pray we can understand the documentation.</p>

<p>Until recently, this was the best we could hope for. But all of that changes with ES7.</p>

<h3>Enter ES7</h3>

<p>What if I told you that, with ES7, you could rewrite the above code to look like this:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">db</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PouchDB</span><span class="p">(</span><span class="s1">'mydb'</span><span class="p">);</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">({});</span>
  <span class="kd">let</span> <span class="nx">doc</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>And what if I told you that, thanks to tools like <a href="https://babeljs.io/">Babel.js</a> and <a href="http://facebook.github.io/regenerator/">Regenerator</a>, you can transpile that down to ES5 and run it in a browser <em>today</em>?</p>

<p><a href="./Taming the asynchronous beast with ES7_files/orson_welles_clapping.gif" target="_blank">
  <img class="img-responsive" src="./Taming the asynchronous beast with ES7_files/orson_welles_clapping.gif" alt="Orson Welles clapping enthusiastically in &#39;Citizen Kane&#39;">
</a></p>

<p>Please ladies and gentlemen, hold your applause until the end of the blog post.</p>

<p>First, let's take a look at how ES7 is accomplishing this amazing feat.</p>

<h3>Async functions</h3>

<p>ES7 gives us a new kind of function, the <code>async function</code>. Inside of an <code>async function</code>, we have a new keyword, <code>await</code>, which we use to "wait for" a promise:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// cool, we have a result</span>
<span class="p">}</span></code></pre></figure>

<p>If the promise resolves, we can immediately interact with it on the next line. And if it rejects, then an error is thrown. So <code>try</code>/<code>catch</code> actually works again!</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="c1">// oh noes, we got an error</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This allows us to write code that looks synchronous on the surface, but is actually asynchronous under the hood. The fact that the API returns a promise instead of blocking the event loop is just an implementation detail.</p>

<p><a href="./Taming the asynchronous beast with ES7_files/pepperidge_farm_remembers.png" target="_blank">
  <img class="img-responsive" src="./Taming the asynchronous beast with ES7_files/pepperidge_farm_remembers.png" alt="Remember when you could just use &#39;return&#39; and &#39;try/catch&#39;? Pepperidge Farm remembers. (Pepperidge Farm meme, old man holding a bag of biscuits and looking at you wistfully.)">
</a></p>

<p>And the best part is, we can use this <em>today</em> with any library that returns promises. PouchDB is such a library, so let's use it to test our theory.</p>

<h3>Managing errors and return values</h3>

<p>First, consider a common idiom in PouchDB: we want to <code>get()</code> a document by <code>_id</code> if it exists, or return a new document if it doesn't.</p>

<p>With promises, you'd have to write something like this:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'docid'</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">'not_found'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{};</span> <span class="c1">// new doc</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span> <span class="c1">// some error other than 404</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">})</span></code></pre></figure>

<p>With async functions, this becomes:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">doc</span><span class="p">;</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="nx">doc</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'docid'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">'not_found'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doc</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span> <span class="c1">// some error other than 404</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span></code></pre></figure>

<p>Much more readable! This is almost the exact same code we would write if <code>db.get()</code> directly returned a document rather than a promise. The only difference is that we have to add the <code>await</code> keyword when we call any promise-returning function.</p>

<h3>Potential gotchas</h3>

<p>There are a few subtle issues that I ran into while playing with this, so it's good to be aware of them.</p>

<p>First off, anytime you <code>await</code> something, you need to be inside an async function. So if your code relies heavily on PouchDB, you may find that you write lots of async functions, but very few regular functions.</p>

<p>Another, more insidious problem is that you have to be careful to wrap your code in <code>try</code>/<code>catch</code>es, or else a promise might be rejected, in which case the error is silently swallowed. (!)</p>

<p>My advice is to ensure that your async functions are entirely surrounded by <code>try</code>/<code>catch</code>es, at least at the top level:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">async</span> <span class="kd">function</span> <span class="nx">createNewDoc</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">({});</span> <span class="c1">// post a new doc</span>
  <span class="k">return</span> <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// find by id</span>
<span class="p">}</span>

<span class="kd">async</span> <span class="kd">function</span> <span class="nx">printDoc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">doc</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">createNewDoc</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3>Loops</h3>

<p>Async functions get really impressive when it comes to iteration. For instance, Let's say that we want to insert some documents into the database, but <em>sequentially</em>. That is, we want the promises to execute one after the other, not concurrently.</p>

<p>Using standard ES6 promises, we'd have to roll our own promise chain:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">promise</span> <span class="o">=</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// now all our docs have been saved</span>
<span class="p">});</span></code></pre></figure>

<p>This works, but it sure is ugly. It's also error-prone, because if you accidentally do:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">promise</span> <span class="o">=</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>
<span class="p">});</span></code></pre></figure>

<p>Then the promises will actually execute <em>concurrently</em>, which can lead to unexpected results.</p>

<p>With ES7, though, we can just use a regular for-loop:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>This (very concise) code does the same thing as the promise chain! We can make it even shorter by using <code>for...of</code>:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">doc</span> <span class="kd">of</span> <span class="nx">docs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Note that you cannot use a  <code>forEach()</code> loop here. If you were to naïvely write:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="c1">// WARNING: this won't work</span>
<span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>Then Babel.js will fail with a somewhat opaque error:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error : /../script.js: Unexpected token (38:23)
&gt; 38 |     await db.post(doc);
     |           ^
</code></pre></div>
<p>This is because you cannot use <code>await</code> from within a normal function. You have to use an async function.</p>

<p>However, if you try to use an async function, then you will get a more subtle bug:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="c1">// WARNING: this won't work</span>
<span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">async</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main loop done'</span><span class="p">);</span></code></pre></figure>

<p>This will compile, but the problem is that this will print out:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">main loop done
0
1
2
</code></pre></div>
<p>What's happening is that the main function is exiting early, because the <code>await</code> is actually in the sub-function. Furthermore, this will execute each promise <em>concurrently</em>, which is not what we intended.</p>

<p>The lesson is: be careful when you have any function inside your async function. The <code>await</code> will only pause its parent function, so check that it's doing what you actually think it's doing.</p>

<h3>Concurrent loops</h3>

<p>If we do want to execute multiple promises concurrently, though, then this is pretty easy to accomplish with ES7.</p>

<p>Recall that with ES6 promises, we have <code>Promise.all()</code>. Let's use it to return an array of values from an array of promises:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="k">return</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
<span class="p">})).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>In ES7, we can do this is a more straightforward way:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
<span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>

<span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">promise</span> <span class="kd">of</span> <span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">await</span> <span class="nx">promise</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span></code></pre></figure>

<p>The most important parts are 1) creating the <code>promises</code> array, which starts invoking all the promises immediately, and 2) that we are <code>await</code>ing those promises within the main function. If we tried to use <code>Array.prototype.map</code>, then it wouldn't work:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
<span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>

<span class="c1">// WARNING: this doesn't work</span>
<span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">async</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">await</span> <span class="nx">promise</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// This will just be a list of promises :(</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span></code></pre></figure>

<p>The reason this doesn't work is because we are <code>await</code>ing inside of the sub-function, and not the main function. So the main function exits before we are really done waiting.</p>

<p>If you don't mind using <code>Promise.all</code>, you can also use it to tidy up the code a bit:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>
<span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">));</span>

<span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="kd">await</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span></code></pre></figure>

<p>Presumably this could look even nicer if we used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions">array comprehesions</a>. However, the spec isn't final yet, so it's currently <a href="https://github.com/facebook/regenerator/issues/182">not supported</a> by Regenerator.</p>

<h3>Caveats</h3>

<p>ES7 is still very bleeding-edge. Async functions aren't supported in either Node.js or io.js, and you have to set some experimental flags to even get Babel to consider it. Officially, <a href="https://github.com/lukehoban/ecmascript-asyncawait#status-of-this-proposal">the async/await spec</a> is still in the "proposal" stage.</p>

<p>Also, you'll need to include the Regenerator runtime and ES6 shims in your transpiled code for this to work in ES5 browsers. For me, that added up to about 60KB, minified and gzipped. For many developers, that's just way too much to ship down the wire.</p>

<p>However, all of these new tools are very fun to play with, and they paint a bright picture of what working with asynchronous libraries will look like in the sunny ES7 future.</p>

<p>So if you want to play with it yourself, I've put together a <a href="https://github.com/nolanlawson/async-functions-in-pouchdb">small demo library</a>. To get started, just check out the code, run <code>npm install &amp;&amp; npm run build</code>, and you're good to go. And for more about ES7, check out <a href="https://www.youtube.com/watch?v=DqMFX91ToLw">this talk by Jafar Husain</a>.</p>

<h3>Conclusion</h3>

<p>Async functions are an empowering new concept in ES7. They give us back our lost <code>return</code>s and <code>try</code>/<code>catch</code>es, and they reward the knowledge we've already gained from writing synchronous code with new idiioms that look a lot like the old ones, but are much more performant.</p>

<p>Most importantly, async functions make APIs like PouchDB's a lot easier to work with. So hopefully this will lead to fewer user errors and confusion, as well as more elegant and readable code.</p>

<p>And who knows, maybe folks will finally abandon LocalStorage, and opt for a more modern client-side database.</p>

    </article>
  </div>
</div>

    </div>

    <div class="band">

      <div class="container">

        <div class="row">

          <div class="col-xs-4 col-md-offset-0 col-md-2">
            <a href="https://twitter.com/pouchdb" target="_blank">
              <div class="icon icon-twitter margin-bottom-none-md"></div>
              <span class="sr-only">PouchDB's Twitter</span>
            </a>
          </div>

          <div class="col-xs-4 col-md-2">
            <a href="https://github.com/rvagg/node-levelup" target="_blank">
              <div class="icon icon-leveldb margin-bottom-none-md"></div>
              <span class="sr-only">Node Levelup</span>
            </a>
          </div>

          <div class="col-xs-4 col-md-2">
            <a href="https://github.com/pouchdb/pouchdb" target="_blank">
              <div class="icon icon-github margin-bottom-none-md"></div>
              <span class="sr-only">PouchDB's Github Repo</span>
            </a>
            </div>

          <div class="col-xs-4 col-md-offset-0 col-md-2">
            <a href="https://travis-ci.org/pouchdb/pouchdb" target="_blank">
              <div class="icon icon-travis margin-bottom-none-md"></div>
              <span class="sr-only">PouchDB's Travis CI</span>
            </a>
          </div>

          <div class="col-xs-4 col-md-2">
            <a href="http://couchdb.apache.org/" target="_blank">
              <div class="icon icon-couchdb margin-bottom-none-md"></div>
              <span class="sr-only">CouchDB</span>
            </a>
          </div>

          <div class="col-xs-4 col-md-2">
            <a href="https://saucelabs.com/" target="_blank">
              <div class="icon icon-saucelabs margin-bottom-none-md"></div>
              <span class="sr-only">Saucelabs</span>
            </a>
          </div>

        </div>

      </div>

    </div>

    <footer class="band band-inverse">

      <div class="container">

        <div class="row">

          <div class="col-sm-3">
            <h3 class="nav-head">Learn</h3>
            <ul class="nav nav-silent">
              <li><a href="https://pouchdb.com/getting-started.html">Getting Started</a></li>
              <li><a href="https://pouchdb.com/api.html">API Guide</a></li>
              <li><a href="https://github.com/pouchdb/pouchdb/wiki">Wiki</a></li>
            </ul>
          </div>

          <div class="col-sm-3">
            <h3 class="nav-head">Discuss</h3>
            <ul class="nav nav-silent">
              <li><a href="https://groups.google.com/forum/#!forum/pouchdb">Mailing List</a></li>
              <li><a href="irc://freenode.net/#pouchdb">IRC</a></li>
              <li><a href="http://slack.pouchdb.com/">Slack</a></li>
              <li><a href="http://twitter.com/pouchdb">Twitter</a></li>
              <li><a href="http://stackoverflow.com/questions/tagged/pouchdb">StackOverflow</a></li>
            </ul>
          </div>

          <div class="col-sm-3">
            <h3 class="nav-head">Contribute</h3>
            <ul class="nav nav-silent">
              <li><a href="https://github.com/pouchdb/pouchdb/blob/master/CONTRIBUTING.md">Contributing</a></li>
              <li><a href="https://github.com/pouchdb/pouchdb">Source</a></li>
              <li><a href="https://github.com/pouchdb/pouchdb/issues">Issues</a></li>
              <li><a href="https://github.com/pouchdb/pouchdb/blob/master/LICENSE">Apache License</a></li>
            </ul>
          </div>

        </div>

      </div>

    </footer>
    <script type="text/javascript" src="./Taming the asynchronous beast with ES7_files/jquery.min.js"></script>
    <script type="text/javascript" src="./Taming the asynchronous beast with ES7_files/bootstrap.min.js"></script>
    <script type="text/javascript" src="./Taming the asynchronous beast with ES7_files/code.min.js"></script>
    <script type="text/javascript" src="./Taming the asynchronous beast with ES7_files/stickyfill.min.js"></script>
    <script type="text/javascript" src="./Taming the asynchronous beast with ES7_files/pouchdb.min.js"></script>
    <script type="text/javascript">
      var $navSidebarWrapper = $('.nav-sidebar-wrapper');
      if ($navSidebarWrapper.length) {
        $navSidebarWrapper.Stickyfill();
      }
      $('[data-toggle="tooltip"]').tooltip();
      function onCached(e) {
        if (applicationCache.status === 1) {
          giveIntro();
        }
      }

      function giveIntro() {
        console.log('%c\n..............................................................................\n.?I...........~+: ............................................................\n.???.........++++.............................................................\n:????+......+++++.............................................................\n.??????+++++++++:.................................H...........D..B............\n...????++++++++...................................H...........D..B............\n...=????++++++.......PPPPP...OOOO...U....U...CCCC.HHHHH...DDDDD..BBBBB........\n...?????+++++++......P...:P.OO...O..U....U..C.....H...H..D....D..B....B.......\n..???????+++++++ ....P. ..P.O....O..U....U.CC.....H...H..D....D..B....B.......\n..?????????????......P...:P.OO...O..U....U..C.....H...H..D....D..B....B.......\n...I??????????~......PPPPP...OOOO...=UUUUU...CCCC.H...H...DDDDD..BBBBB........\n....?????????~.......P.... ...................................................\n.....???????+........P........................................................\n......??????..................................................................\n..............................................................................\n..............................................................................\n..............................................................................', 'color: #4ec084');
        console.log('%c\nPouchDB itself is hosted at PouchDB.com!\nTo get started, try typing:\nvar db = new PouchDB(\'mydb\');', 'color: #4ec084');
      }
      function offerToReload() {
        $('.js-update-notification')
          .removeClass('btn-update-hidden')
          .on('click', function(){
            window.location.reload();
          });
      }
      if (window.applicationCache) {
        applicationCache.addEventListener('cached', onCached, false);
        applicationCache.addEventListener('noupdate', giveIntro, false);
        applicationCache.addEventListener('updateready', offerToReload, false);
      }
    </script>
    <button type="button" class="js-update-notification btn btn-primary btn-update btn-update-hidden">
      Content updated, reload now? ↻
    </button>
  

</body></html>